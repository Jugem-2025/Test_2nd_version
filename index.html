<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Adventure of Washi-chan and Shiwa-chan</title>
  <style>
    body {
      background-color: #CC0000; /* Red */
      color: black; /* Black */
      font-size: 24pt; /* 24pt */
      font-family: "Yu Mincho", serif; /* Keeping for aesthetic, can change if needed */
      line-height: 1.6;
      padding: 80px 40px;
      overflow: hidden; /* Prevent scrollbars during animation */
      display: flex;
      justify-content: center; /* Horizontally center content */
      align-items: flex-start; /* Vertically align content to top */
      min-height: 100vh; /* Full viewport height */
      box-sizing: border-box;
      position: relative;
    }

    .story-container {
      max-width: 800px; /* Fixed width to prevent layout shifts */
      text-align: left;
      position: relative; /* For positioning characters absolutely relative to this container */
    }

    .story span {
      display: inline-block;
      position: relative; /* Base for transform */
      transition: transform 1.5s ease-in, opacity 1.5s ease-in;
      will-change: transform, opacity;
      white-space: pre; /* Preserve white space for layout integrity */
    }

    .falling {
      transform: translateY(60vh) rotateZ(calc(90deg * var(--random-rotation))) translateX(calc(200px * var(--random-x)));
      opacity: 0; /* Fully disappear */
    }

    .remaining {
      opacity: 1; /* Always visible */
      position: absolute; /* Take out of flow for precise movement */
      color: black;
      /* Initial position set by JS before transform */
    }

    .remaining.animate-to-center {
      transition: transform 2s ease-out, font-size 0.5s ease-out 1.5s; /* Smooth movement and delayed size change */
      z-index: 10; /* Ensure on top */
    }

    .remaining.animate-to-center.final-position {
      font-size: 48pt !important; /* Double the size */
    }
  </style>
</head>
<body>
  <div class="story-container" id="story-container">
    <div class="story" id="story">
    </div>
  </div>

  <script>
    const text = `Deep in the forest, nestled beside moss-covered ancient trees and a sparkling stream, Washi-chan and fluffy Shiwa-chan lived peacefully. Their days began by treading on dew-kissed grass and listening to the birds' melodies. Washi-chan was a wise being who knew all about the forest, while Shiwa-chan was a curious and kind-hearted soul who found joy in every small discovery.

One summer afternoon, they ventured further than usual, into a place so dense that sunlight barely reached. There, they found an old, forgotten shrine, standing quietly. When Shiwa-chan nervously tugged at Washi-chan's sleeve, Washi-chan gently held their hand and smiled softly. "It's okay, Shiwa-chan. There's beauty to be found even in the deepest places."

Encouraged by those words, Shiwa-chan peered into the shrine's depths and discovered a small stone, sparkling with seven colors in the faint light. It seemed to embody the very memories of the forest. They carefully took the stone home and placed it on their cottage windowsill. From that day on, the stone gently illuminated their lives, becoming a treasure that warmed their hearts.

Seasons came and went, and the forest showed many faces, but the bond between Washi-chan and Shiwa-chan continued to shine brightly, like that seven-colored stone. They knew that their mutual existence was the most precious treasure of all.`;

    const storyContainer = document.getElementById("story");
    const fullStoryContainer = document.getElementById("story-container"); // The container with fixed width
    let spans = [];

    const charactersToKeep = [
      { char: 'w', count: 2, originalChar: 'w', indices: [] }, // Added originalChar for case preservation logic
      { char: 'a', count: 2, originalChar: 'a', indices: [] },
      { char: 's', count: 2, originalChar: 's', indices: [] },
      { char: 'h', count: 2, originalChar: 'h', indices: [] },
      { char: 'i', count: 2, originalChar: 'i', indices: [] }
    ];
    let keptIndices = new Set(); // To ensure unique positions for kept letters

    function findKeepIndices() {
      // Create a temporary array of characters from the text to find suitable indices
      const tempChars = text.split('');

      charactersToKeep.forEach(target => {
        let count = 0;
        while (count < target.count) {
          let randomIndex;
          let foundSuitable = false;
          let attempts = 0;
          const maxAttempts = 2000; // Increased attempts for better chance

          while (!foundSuitable && attempts < maxAttempts) {
            randomIndex = Math.floor(Math.random() * tempChars.length);
            const actualCharAtIndex = tempChars[randomIndex].toLowerCase();

            if (actualCharAtIndex === target.char && !keptIndices.has(randomIndex)) {
              let tooClose = false;
              // Check proximity to existing kept indices
              for (let keptIdx of keptIndices) {
                if (Math.abs(randomIndex - keptIdx) < 5) { // Ensure at least 5 characters separation
                  tooClose = true;
                  break;
                }
              }
              if (!tooClose) {
                foundSuitable = true;
              }
            }
            attempts++;
          }

          if (foundSuitable) {
            target.indices.push(randomIndex);
            keptIndices.add(randomIndex);
            count++;
          } else {
            // Fallback: if cannot find separated unique indices, find any unique index
            console.warn(`Could not find a separated unique index for '${target.char}'. Trying any unique index.`);
            let fallbackIndex;
            let fallbackAttempts = 0;
            while(fallbackAttempts < maxAttempts) {
                fallbackIndex = Math.floor(Math.random() * tempChars.length);
                if (tempChars[fallbackIndex].toLowerCase() === target.char && !keptIndices.has(fallbackIndex)) {
                    foundSuitable = true;
                    break;
                }
                fallbackAttempts++;
            }
            if (foundSuitable) {
                target.indices.push(fallbackIndex);
                keptIndices.add(fallbackIndex);
                count++;
            } else {
                console.error(`Failed to find any unique index for character '${target.char}' (instance ${count + 1}).`);
                break;
            }
          }
        }
      });
    }

    // Determine indices *before* creating spans
    findKeepIndices();

    // Create spans for each character
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      const span = document.createElement("span");
      span.textContent = char;
      span.setAttribute('data-index', i); // Store original index

      if (keptIndices.has(i)) {
        span.classList.add("remaining");
        // Store the original character to preserve its case if it's W, S, A, I, H
        // before potentially changing it to 'W' or 'S' later.
        span.setAttribute('data-original-char', char);
      }
      storyContainer.appendChild(span);
      spans.push(span);
    }

    const remainingSpans = spans.filter(span => span.classList.contains('remaining'));

    // Capture initial positions of remaining spans *after* they've been rendered in their original flow.
    // This needs to happen after the DOM is laid out.
    // Use requestAnimationFrame to ensure layout is complete.
    requestAnimationFrame(() => {
        remainingSpans.forEach(span => {
            const rect = span.getBoundingClientRect();
            // Set initial absolute position relative to the viewport
            span.style.left = `${rect.left}px`;
            span.style.top = `${rect.top}px`;
            // Crucial: Take them out of the document flow after their initial position is captured
            // This prevents them from affecting the layout as other text falls.
            // Also, setting position:absolute means their 'top' and 'left' are relative to the *nearest positioned ancestor*.
            // Since body has position:relative, they are relative to the viewport.
        });

        // Initial 3 seconds delay before any animation starts
        setTimeout(() => {
          let maxFallTime = 0; // To track when all characters have fallen

          spans.forEach((span) => {
            if (!span.classList.contains("remaining")) {
              const charRect = span.getBoundingClientRect();
              const startRect = spans[0].getBoundingClientRect(); // Reference first char for distance
              const distance = Math.sqrt(Math.pow(charRect.left - startRect.left, 2) + Math.pow(charRect.top - startRect.top, 2));
              const delay = distance * 5; // Distance 1px = 5ms delay

              const randomRotation = Math.random() * 2 - 1;
              const randomX = Math.random() * 2 - 1;
              span.style.setProperty('--random-rotation', randomRotation);
              span.style.setProperty('--random-x', randomX);

              setTimeout(() => {
                span.classList.add("falling");
              }, delay);
              // Calculate when this character will finish falling
              const fallFinishTime = delay + 1500; // 1500ms is the transition duration
              if (fallFinishTime > maxFallTime) {
                maxFallTime = fallFinishTime;
              }
            }
          });

          // After all falling animations are complete (or a buffer time)
          setTimeout(() => {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;

            // Target positions for "Washi" and "Shiwa" (adjust as needed for perfect centering)
            const washiTargetY = viewportHeight / 2 - 25; // Slightly above center for 'Washi'
            const shiwaTargetY = viewportHeight / 2 + 25; // Slightly below center for 'Shiwa'

            const letterWidthEstimate = 24; // Approximation for 24pt font, adjust if necessary
            const wordWashiWidth = 'Washi'.length * letterWidthEstimate;
            const wordShiwaWidth = 'Shiwa'.length * letterWidthEstimate;

            // Define the final characters and their target positions in the center
            const finalArrangement = [
              { char: 'W', targetX: (viewportWidth / 2) - (wordWashiWidth / 2), targetY: washiTargetY },
              { char: 'a', targetX: (viewportWidth / 2) - (wordWashiWidth / 2) + (1 * letterWidthEstimate), targetY: washiTargetY },
              { char: 's', targetX: (viewportWidth / 2) - (wordWashiWidth / 2) + (2 * letterWidthEstimate), targetY: washiTargetY },
              { char: 'h', targetX: (viewportWidth / 2) - (wordWashiWidth / 2) + (3 * letterWidthEstimate), targetY: washiTargetY },
              { char: 'i', targetX: (viewportWidth / 2) - (wordWashiWidth / 2) + (4 * letterWidthEstimate), targetY: washiTargetY },
              { char: 'S', targetX: (viewportWidth / 2) - (wordShiwaWidth / 2), targetY: shiwaTargetY },
              { char: 'h', targetX: (viewportWidth / 2) - (wordShiwaWidth / 2) + (1 * letterWidthEstimate), targetY: shiwaTargetY },
              { char: 'i', targetX: (viewportWidth / 2) - (wordShiwaWidth / 2) + (2 * letterWidthEstimate), targetY: shiwaTargetY },
              { char: 'w', targetX: (viewportWidth / 2) - (wordShiwaWidth / 2) + (3 * letterWidthEstimate), targetY: shiwaTargetY },
              { char: 'a', targetX: (viewportWidth / 2) - (wordShiwaWidth / 2) + (4 * letterWidthEstimate), targetY: shiwaTargetY }
            ];

            // Sort remainingSpans by their original index to match `finalArrangement`
            remainingSpans.sort((a, b) => parseInt(a.dataset.index) - parseInt(b.dataset.index));

            // Assign the sorted remaining spans to their final target positions
            remainingSpans.forEach((span, i) => {
              const target = finalArrangement[i];
              if (target) {
                // Set text content based on the target character, preserving case for W and S
                span.textContent = target.char;

                // Get current position (which is the initial captured position)
                const currentRect = span.getBoundingClientRect();

                // Calculate the delta for the transform
                const deltaX = target.targetX - currentRect.left;
                const deltaY = target.targetY - currentRect.top;

                // Apply the transform for smooth movement
                span.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
                span.classList.add('animate-to-center'); // Add class to enable CSS transition
              }
            });

            // Set size change to happen 1.5 seconds before movement ends
            setTimeout(() => {
              remainingSpans.forEach(span => {
                span.classList.add('final-position');
              });
            }, 500); // 0.5s into the 2s movement duration

          }, maxFallTime + 100); // Small buffer after all characters have finished falling
        }, 3000); // Initial delay before any animation
    });
  </script>
</body>
</html>
