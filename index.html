<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Adventures of Washi-chan and Shiwa-chan</title>
  <style>
    body {
      background-color: #CC0000; /* Red */
      color: black; /* Black */
      font-size: 24pt; /* 24 points */
      font-family: "Yu Mincho", serif;
      line-height: 1.6;
      padding: 80px 40px; /* Increased top padding for better fall visibility */
      overflow: hidden; /* Prevent scrollbar from falling text */
      display: flex; /* Use flexbox for centering */
      justify-content: center; /* Horizontal centering */
      align-items: flex-start; /* Vertical top alignment */
      min-height: 100vh; /* Full screen height */
      box-sizing: border-box; /* Include padding in width/height */
      position: relative; /* For absolute positioning of final words */
    }

    .story {
      max-width: 800px; /* Moderate width for readability */
      text-align: left; /* Left align for top-down collapse */
    }

    .story span {
      display: inline-block;
      position: relative; /* Reference point for transform */
      transition: transform 1.5s ease-in, opacity 1.5s ease-in, font-size 0.5s ease-out; /* Faster fall, added font-size transition */
      will-change: transform, opacity, font-size; /* Improve animation performance */
    }

    .falling {
      /* Stops slightly below screen center, with significant horizontal drift */
      transform: translateY(60vh) rotateZ(calc(90deg * var(--random-rotation))) translateX(calc(200px * var(--random-x)));
      opacity: 1; /* Color remains black */
    }

    .static {
      /* Style for characters that do not fall */
      opacity: 1;
      transform: none;
      transition: all 1.5s ease-in-out; /* Smooth transition for final arrangement */
      z-index: 10; /* Ensure they are above other elements if needed */
    }

    .final-size {
      font-size: 48pt; /* Double the size */
    }
  </style>
</head>
<body>
  <div class="story" id="story">
  </div>

  <script>
    // Sample text (Heartwarming story of Washi-chan and Shiwa-chan - approx. 200 words)
    const text = `Deep within the forest, by moss-covered trees and a shimmering stream, Washi-chan and fluffy Shiwa-chan lived peacefully. Their days began by treading on dew-kissed grass and listening to birdsongs. Washi-chan was a wise being who knew all of the forest, while Shiwa-chan was curious and kind-hearted, finding joy in every small discovery.

One summer afternoon, they ventured further than usual, into a place so dense with sunlight barely reached. There stood an ancient, forgotten shrine, quietly nestled. Shiwa-chan nervously tugged Washi-chan's sleeve, but Washi-chan gently held their hand and smiled softly. "It's alright, Shiwa-chan. There's surely beauty to be found everywhere."

Encouraged by these words, Shiwa-chan peeked into the back of the shrine and discovered a small stone, shining in seven colors as it caught the light. It was as if the memory of the forest itself. They carefully carried the stone home and placed it by their cottage window. Since then, the stone gently illuminated their days, becoming a treasure that warmed their hearts.

Seasons passed, and the forest showed many faces, but the bond between Washi-chan and Shiwa-chan continued to shine eternally, just like that seven-colored stone. For they knew that each other's presence was their most precious treasure.`;

    const storyContainer = document.getElementById("story");
    const charactersToKeep = ['w', 'a', 's', 'h', 'i']; // Characters needed for "Washi" and "Shiwa"
    let keptIndices = [];
    let allSpans = [];

    // One character at a time into span
    for (let char of text) {
      const span = document.createElement("span");
      span.textContent = char;
      storyContainer.appendChild(span);
      allSpans.push(span);
    }

    // Function to get a random non-adjacent index for a character to keep
    const getRandomNonAdjacentIndex = (char, spansArray, currentKeptIndices) => {
      let attempts = 0;
      while (attempts < 100) { // Limit attempts to prevent infinite loop
        const indices = [];
        for (let i = 0; i < spansArray.length; i++) {
          // Check if the character matches and it hasn't been kept already
          if (spansArray[i].textContent.toLowerCase() === char && !currentKeptIndices.includes(i)) {
            indices.push(i);
          }
        }
        if (indices.length === 0) return -1; // Character not found or all occurrences kept

        const randomIndex = indices[Math.floor(Math.random() * indices.length)];
        // Check if the chosen index or its neighbors are already kept
        const isAdjacent = currentKeptIndices.some(keptIdx =>
          Math.abs(keptIdx - randomIndex) <= 2 // Check up to 2 characters away
        );
        if (!isAdjacent) {
          return randomIndex;
        }
        attempts++;
      }
      return -1; // Could not find a suitable non-adjacent index
    };

    // Select characters to keep ensuring we have enough for both "Washi" and "Shiwa"
    // We need 1 'w', 2 'a', 2 's', 2 'h', 2 'i' for "Washi" and "Shiwa" combined (Washi, Shiwa)
    const requiredChars = { 'w': 2, 'a': 2, 's': 2, 'h': 2, 'i': 2 }; // W, a, s, h, i for Washi; S, h, i, w, a for Shiwa
    let selectedSpans = [];

    // Helper to get a specific number of unique characters
    const selectUniqueChars = (char, count) => {
        let foundCount = 0;
        let tempKeptIndices = [...keptIndices]; // Use a temporary array to check against current selections
        for (let i = 0; i < allSpans.length && foundCount < count; i++) {
            if (allSpans[i].textContent.toLowerCase() === char && !tempKeptIndices.includes(i)) {
                const indexToKeep = getRandomNonAdjacentIndex(char, allSpans, tempKeptIndices);
                if (indexToKeep !== -1) {
                    keptIndices.push(indexToKeep);
                    tempKeptIndices.push(indexToKeep); // Add to temp for adjacency check
                    selectedSpans.push(allSpans[indexToKeep]);
                    foundCount++;
                }
            }
        }
    };

    // Ensure we select enough of each character type for both words
    selectUniqueChars('w', 2); // 1 for Washi, 1 for Shiwa
    selectUniqueChars('a', 2); // 1 for Washi, 1 for Shiwa
    selectUniqueChars('s', 2); // 1 for Washi, 1 for Shiwa (Shiwa needs 's', Washi needs 's')
    selectUniqueChars('h', 2); // 1 for Washi, 1 for Shiwa
    selectUniqueChars('i', 2); // 1 for Washi, 1 for Shiwa


    // Sort kept indices to ensure the original order of remaining characters
    keptIndices.sort((a, b) => a - b);


    // Start animation after 3 seconds
    setTimeout(() => {
      const spans = Array.from(document.querySelectorAll(".story span"));

      // Base starting point (using the first character's position as reference)
      // Wait for rendering once to get initial character positions
      requestAnimationFrame(() => {
        const startRect = spans[0].getBoundingClientRect();
        const startX = startRect.left;
        const startY = startRect.top;

        let fallingCount = 0;
        const totalFallingSpans = spans.length - keptIndices.length;

        spans.forEach((span, index) => {
          const charRect = span.getBoundingClientRect();
          const charX = charRect.left;
          const charY = charRect.top;

          // Calculate Euclidean distance from the starting point
          // Shorter distance falls faster, longer distance falls slower
          const distance = Math.sqrt(Math.pow(charX - startX, 2) + Math.pow(charY - startY, 2));
          const delay = distance * 5; // Delay in milliseconds per 1px distance

          const randomRotation = Math.random() * 2 - 1; // Random value from -1 to 1 (more rotation)
          const randomX = Math.random() * 2 - 1; // Random value from -1 to 1 (more horizontal drift)
          span.style.setProperty('--random-rotation', randomRotation);
          span.style.setProperty('--random-x', randomX);

          if (!keptIndices.includes(index)) {
            setTimeout(() => {
              span.classList.add("falling");
              fallingCount++;
              if (fallingCount === totalFallingSpans) {
                // All falling characters have started their animation
                setTimeout(arrangeKeptWords, 1500); // Wait for characters to fall completely (1.5s transition)
              }
            }, delay);
          } else {
            // Add static class to characters that remain
            span.classList.add("static");
          }
        });
      });
    }, 3000); // Initial 3 second wait

    function arrangeKeptWords() {
      // Clear the original story container
      storyContainer.innerHTML = '';

      const finalWordContainer = document.createElement('div');
      finalWordContainer.style.display = 'flex';
      finalWordContainer.style.flexDirection = 'column';
      finalWordContainer.style.alignItems = 'center';
      finalWordContainer.style.justifyContent = 'center';
      finalWordContainer.style.position = 'absolute';
      finalWordContainer.style.top = '50%';
      finalWordContainer.style.left = '50%';
      finalWordContainer.style.transform = 'translate(-50%, -50%)';
      finalWordContainer.style.gap = '20px'; // Space between words

      const washiDiv = document.createElement('div');
      washiDiv.style.display = 'flex';
      const shiwaDiv = document.createElement('div');
      shiwaDiv.style.display = 'flex';

      const desiredWashi = ['W', 'a', 's', 'h', 'i'];
      const desiredShiwa = ['S', 'h', 'i', 'w', 'a'];

      let availableChars = {}; // Map to store counts of available characters (case-insensitive)
      let availableSpanElements = {}; // Map to store the actual span elements

      // Populate availableChars and availableSpanElements from selectedSpans
      selectedSpans.forEach(span => {
          const charLower = span.textContent.toLowerCase();
          if (!availableChars[charLower]) {
              availableChars[charLower] = 0;
              availableSpanElements[charLower] = [];
          }
          availableChars[charLower]++;
          availableSpanElements[charLower].push(span);
      });

      // Function to get and use a character, preferring specific case if available
      const getCharSpan = (targetChar, charMap, spanMap) => {
          const charLower = targetChar.toLowerCase();
          if (charMap[charLower] > 0 && spanMap[charLower].length > 0) {
              charMap[charLower]--;
              // Find a span element that matches the target case first, then any case
              const perfectMatchIndex = spanMap[charLower].findIndex(s => s.textContent === targetChar);
              if (perfectMatchIndex !== -1) {
                  const span = spanMap[charLower].splice(perfectMatchIndex, 1)[0];
                  span.textContent = targetChar; // Ensure correct case
                  return span;
              } else {
                  const span = spanMap[charLower].shift(); // Take any available if no perfect match
                  span.textContent = targetChar; // Ensure correct case
                  return span;
              }
          }
          return null;
      };

      // Construct "Washi"
      desiredWashi.forEach(char => {
          const span = getCharSpan(char, availableChars, availableSpanElements);
          if (span) {
              washiDiv.appendChild(span);
          }
      });

      // Construct "Shiwa"
      desiredShiwa.forEach(char => {
          const span = getCharSpan(char, availableChars, availableSpanElements);
          if (span) {
              shiwaDiv.appendChild(span);
          }
      });

      finalWordContainer.appendChild(washiDiv);
      finalWordContainer.appendChild(shiwaDiv);
      document.body.appendChild(finalWordContainer);

      // Start size increase 1.5 seconds before final arrangement
      setTimeout(() => {
        // Collect all spans that are part of Washi and Shiwa
        const allFinalSpans = Array.from(washiDiv.children).concat(Array.from(shiwaDiv.children));
        allFinalSpans.forEach(span => {
          span.classList.add('final-size');
        });
      }, 0); // Start immediately since they are already in place
    }
  </script>
</body>
</html>
