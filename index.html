<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>The Adventure of Washi-chan and Shiwa-chan</title>
  <style>
    body {
      background-color: #CC0000; /* Red */
      color: black; /* Black */
      font-size: 24pt; /* 24pt */
      font-family: "Yu Mincho", serif; /* Keeping for aesthetic, can change if needed */
      line-height: 1.6;
      padding: 80px 40px;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      box-sizing: border-box;
      position: relative; /* For absolute positioning of remaining letters */
    }

    .story {
      max-width: 800px;
      text-align: left;
    }

    .story span {
      display: inline-block;
      position: relative;
      transition: transform 1.5s ease-in, opacity 1.5s ease-in;
      will-change: transform, opacity;
      white-space: pre; /* Preserve white space */
    }

    .falling {
      transform: translateY(60vh) rotateZ(calc(90deg * var(--random-rotation))) translateX(calc(200px * var(--random-x)));
      opacity: 0; /* Changed to 0 for full disappearance */
    }

    /* Initial state for remaining letters (fixed position, no transform yet) */
    .remaining {
      opacity: 1; /* Ensure visibility */
      position: absolute; /* Allows precise positioning later */
      color: black; /* Ensure color remains black */
      /* No transform initially, will be applied in JS */
    }

    /* Animation for moving and sizing remaining letters */
    .remaining.animate-to-center {
      transition: transform 2s ease-out, font-size 0.5s ease-out 1.5s; /* Font size transition starts later */
      z-index: 10; /* Ensure they are on top */
    }

    .remaining.animate-to-center.final-position {
      font-size: 48pt !important; /* Double the size */
    }
  </style>
</head>
<body>
  <div class="story" id="story">
  </div>

  <script>
    const text = `Deep in the forest, nestled beside moss-covered ancient trees and a sparkling stream, Washi-chan and fluffy Shiwa-chan lived peacefully. Their days began by treading on dew-kissed grass and listening to the birds' melodies. Washi-chan was a wise being who knew all about the forest, while Shiwa-chan was a curious and kind-hearted soul who found joy in every small discovery.

One summer afternoon, they ventured further than usual, into a place so dense that sunlight barely reached. There, they found an old, forgotten shrine, standing quietly. When Shiwa-chan nervously tugged at Washi-chan's sleeve, Washi-chan gently held their hand and smiled softly. "It's okay, Shiwa-chan. There's beauty to be found even in the deepest places."

Encouraged by those words, Shiwa-chan peered into the shrine's depths and discovered a small stone, sparkling with seven colors in the faint light. It seemed to embody the very memories of the forest. They carefully took the stone home and placed it on their cottage windowsill. From that day on, the stone gently illuminated their lives, becoming a treasure that warmed their hearts.

Seasons came and went, and the forest showed many faces, but the bond between Washi-chan and Shiwa-chan continued to shine brightly, like that seven-colored stone. They knew that their mutual existence was the most precious treasure of all.`;

    const storyContainer = document.getElementById("story");
    let spans = []; // Store spans to access later

    // Characters to remain, each appearing twice, ensuring separation
    const charactersToKeep = [
      { char: 'w', count: 2, indices: [] },
      { char: 'a', count: 2, indices: [] },
      { char: 's', count: 2, indices: [] },
      { char: 'h', count: 2, indices: [] },
      { char: 'i', count: 2, indices: [] }
    ];
    let keptIndices = new Set(); // To ensure unique positions for kept letters

    // Function to find suitable indices for characters to keep
    function findKeepIndices() {
      const tempSpans = [];
      // Treat text as individual characters for index finding
      for (let char of text) {
        tempSpans.push(char);
      }

      charactersToKeep.forEach(target => {
        let count = 0;
        while (count < target.count) {
          const char = target.char;
          let randomIndex;
          let foundSuitable = false;
          let attempts = 0;
          const maxAttempts = 1000;

          while (!foundSuitable && attempts < maxAttempts) {
            randomIndex = Math.floor(Math.random() * tempSpans.length);
            const actualCharAtIndex = tempSpans[randomIndex].toLowerCase();

            // Ensure it's the target character, not already kept, and sufficiently far from others
            if (actualCharAtIndex === char && !keptIndices.has(randomIndex)) {
              let tooClose = false;
              for (let keptIdx of keptIndices) {
                if (Math.abs(randomIndex - keptIdx) < 5) { // Ensure at least 5 characters separation
                  tooClose = true;
                  break;
                }
              }
              if (!tooClose) {
                foundSuitable = true;
              }
            }
            attempts++;
          }

          if (foundSuitable) {
            target.indices.push(randomIndex);
            keptIndices.add(randomIndex);
            count++;
          } else {
            console.warn(`Could not find a suitable unique index for character '${char}' (instance ${count + 1}).`);
            break;
          }
        }
      });
    }

    // Call this before creating spans to determine which to keep
    findKeepIndices();

    // Create spans for each character and mark those to keep
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      const span = document.createElement("span");
      span.textContent = char;
      span.setAttribute('data-index', i); // Store original index

      if (keptIndices.has(i)) {
        span.classList.add("remaining");
        // For remaining characters, set their initial absolute position immediately
        // This must be done AFTER the span is appended to the DOM for getBoundingClientRect to work
        // and BEFORE any transforms are applied, to capture their true initial render position.
      }
      storyContainer.appendChild(span);
      spans.push(span);
    }

    // Filter out only the spans that will remain
    const remainingSpans = spans.filter(span => span.classList.contains('remaining'));

    // Capture initial positions of remaining spans *after* they've been rendered
    // This is crucial for smooth transition from their original place.
    const initialRemainingPositions = new Map();
    remainingSpans.forEach(span => {
      const rect = span.getBoundingClientRect();
      initialRemainingPositions.set(span, { left: rect.left, top: rect.top });
      // Apply initial absolute positioning
      span.style.left = `${rect.left}px`;
      span.style.top = `${rect.top}px`;
    });

    // 3 seconds delay before animation starts
    setTimeout(() => {
      let maxFallTime = 0; // To track when all characters have fallen

      spans.forEach((span, index) => {
        // Only apply falling animation to non-remaining characters
        if (!span.classList.contains("remaining")) {
          const charRect = span.getBoundingClientRect();
          // Use a fixed start reference for falling characters
          const startRect = spans[0].getBoundingClientRect();
          const startX = startRect.left;
          const startY = startRect.top;

          const distance = Math.sqrt(Math.pow(charRect.left - startX, 2) + Math.pow(charRect.top - startY, 2));
          const delay = distance * 5; // Distance 1px = 5ms delay

          const randomRotation = Math.random() * 2 - 1;
          const randomX = Math.random() * 2 - 1;
          span.style.setProperty('--random-rotation', randomRotation);
          span.style.setProperty('--random-x', randomX);

          setTimeout(() => {
            span.classList.add("falling");
          }, delay);
          // Calculate when this character will finish falling
          const fallFinishTime = delay + 1500; // 1500ms is the transition duration
          if (fallFinishTime > maxFallTime) {
            maxFallTime = fallFinishTime;
          }
        }
      });

      // After all falling animations are complete
      setTimeout(() => {
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;

        // Target positions for "Washi" and "Shiwa" (adjust as needed for perfect centering)
        const washiTargetY = viewportHeight / 2 - 25; // Slightly above center
        const shiwaTargetY = viewportHeight / 2 + 25; // Slightly below center

        const letterWidthEstimate = 24; // Approximation for 24pt font, adjust if necessary
        const wordWashiWidth = 'Washi'.length * letterWidthEstimate;
        const wordShiwaWidth = 'Shiwa'.length * letterWidthEstimate;

        // Map characters to their final desired positions and indices
        // IMPORTANT: The order here must match the intended order of remainingSpans after sorting
        const finalArrangement = [
          { char: 'W', targetX: (viewportWidth / 2) - (wordWashiWidth / 2), targetY: washiTargetY },
          { char: 'a', targetX: (viewportWidth / 2) - (wordWashiWidth / 2) + (1 * letterWidthEstimate), targetY: washiTargetY },
          { char: 's', targetX: (viewportWidth / 2) - (wordWashiWidth / 2) + (2 * letterWidthEstimate), targetY: washiTargetY },
          { char: 'h', targetX: (viewportWidth / 2) - (wordWashiWidth / 2) + (3 * letterWidthEstimate), targetY: washiTargetY },
          { char: 'i', targetX: (viewportWidth / 2) - (wordWashiWidth / 2) + (4 * letterWidthEstimate), targetY: washiTargetY },
          { char: 'S', targetX: (viewportWidth / 2) - (wordShiwaWidth / 2), targetY: shiwaTargetY },
          { char: 'h', targetX: (viewportWidth / 2) - (wordShiwaWidth / 2) + (1 * letterWidthEstimate), targetY: shiwaTargetY },
          { char: 'i', targetX: (viewportWidth / 2) - (wordShiwaWidth / 2) + (2 * letterWidthEstimate), targetY: shiwaTargetY },
          { char: 'w', targetX: (viewportWidth / 2) - (wordShiwaWidth / 2) + (3 * letterWidthEstimate), targetY: shiwaTargetY },
          { char: 'a', targetX: (viewportWidth / 2) - (wordShiwaWidth / 2) + (4 * letterWidthEstimate), targetY: shiwaTargetY }
        ];

        // Sort remainingSpans by their original index to maintain a consistent order for mapping
        remainingSpans.sort((a, b) => parseInt(a.dataset.index) - parseInt(b.dataset.index));

        remainingSpans.forEach((span, i) => {
          const target = finalArrangement[i];
          if (target) {
            // Ensure correct capitalization for 'Washi' and 'Shiwa'
            if (i === 0) span.textContent = 'W'; // First char for Washi
            if (i === 5) span.textContent = 'S'; // First char for Shiwa

            // Get initial position relative to the viewport
            const initialPos = initialRemainingPositions.get(span);

            // Calculate the delta for the transform
            const deltaX = target.targetX - initialPos.left;
            const deltaY = target.targetY - initialPos.top;

            // Apply the transform for smooth movement
            span.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
            span.classList.add('animate-to-center'); // Add class to enable transition
          }
        });

        // Set size change to happen 1.5 seconds before movement ends (2s - 1.5s = 0.5s into movement)
        setTimeout(() => {
          remainingSpans.forEach(span => {
            span.classList.add('final-position');
          });
        }, 500); // 0.5s into the movement (which lasts 2s)

      }, maxFallTime + 100); // Wait a little extra after all characters have fallen
    }, 3000); // Initial 3 seconds delay before any animation starts
  </script>
</body>
</html>
